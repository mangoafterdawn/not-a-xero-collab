<Mods LoadCommand = "%xero(function(self)
	local spritepoolindex = {}
	for k, v in ipairs(spritepool) do
		spritepoolindex[v] = k
	end
	local function spriteordering(a, b) return spritepoolindex[a] < spritepoolindex[b] end
	function funcQ(t)
		local quad
		func {t[1], function()
			quad = table.remove(spritepool)
			if not quad then SCREENMAN:SystemMessage('out') return end
			quad:hidden(0)
			t[3](quad)
		end}
		if t[4] then
			func{t[1], t[2], linear, 0, 1, function(p) t[4](quad, p) end}
		end
		func {t[1] + t[2], function()
			if not quad then return end
			quad:hidden(1)
			quad:x(scx)
			quad:y(scy)
			quad:cropleft(0)
			quad:cropright(0)
			quad:croptop(0)
			quad:cropbottom(0)
			quad:rotationz(0)
			quad:diffuse(1, 1, 1, 1)
			quad:blend 'normal'
			table.insert(spritepool, quad)
			table.sort(spritepool, spriteordering)
		end}
		return funcQ
	end
	
	function cropconvert(n)
		return (n * 640 - 320 + scx) / sw
	end


	funcQ {0, 27.5, function(quad)
		quad:diffusealpha(0.5)
		quad:rotationz(2)
	end}
	{0, 27.5, function(quad)
		quad:blend 'invertdest'
		quad:y(scy+20)
		quad:rotationz(-4)
	end}
	{0, 27.5, function(quad)
		quad:diffuse(1, 0, 0, 1)
		quad:blend 'add'
		quad:x(scx+5)
		quad:y(scy+20)
		quad:cropleft(0.5)
	end}

	alias {'confusionzoffset', 'confusionoffset'}

	set {0, .5, 'mask'}
	func {22, 4, inOutCubic, 1, 0, function(p) masksprite:diffusealpha(p) end}
	set {26, 0, 'mask'}
	func {26, function()
		masksprite:diffusealpha(1)
		masksprite:rotationz(0)
		masksprite:zoom(1)
		masksprite:SetTextureFiltering(false)
	end}
	ease {58, 81, m=e, linear, 0.6, 'mask'}
	ease {82, 2, function(x) return math.cos(x * 4 * math.pi) end , 1, 'mask'}
	set {84, 0, 'mask'}
	func {84, function()
		masksprite:zoom(1.005)
	end}

	set {0,
		100, 'stealth',
		100, 'dark',
		-100, 'invert',
		100, 'flip',
		100, 'reverse',
		314, 'confusionoffset',
		-180, 'proxyrotz',
	}

	add {0, 0, instant, -128, 'xpos', plr=1}
	add {0, 0, instant, 128, 'xpos', plr=2}

	ease {0, 27.5, bell, -100, 'tiny0'}
	ease {0, 26.5, bell, -100, 'tiny1'}
	ease {0, 25.5, bell, -100, 'tiny2'}
	ease {0, 24.5, bell, -100, 'tiny3'}

	ease {0, 27.5, inOutQuad, 0, 'confusionoffset', 0, 'proxyrotz'}
	ease {0, 27.5, inOutQuad, 0, 'reverse'}

	local pn = 1
	for i, v in {
		{0, 0},
		{1.5, 3},
		{2.5, 2},
		{3, 1},
		{13.5, 3},
		{14, 1},
		{15.5, 2},
		{16.5, 3},
		{17, 1},
		{18.5, 0},
		{19.5, 2},
		{20.25, 1},
		{21, 0},
		{22, 2},
		{22.5, 3},
		{23.25, 0},
		{24, 1},
		{25.5, 1},
		{27, 3},
	} do
		ease {v[1], 4, pop, -30, 'dark'..v[2], -100, 'stealth'..v[2], plr = pn}
		pn = 3 - pn
	end
	reset {25, 4, inOutQuad}
	
	local coldata = {
		[0] = {.3, .6},
		[1] = {.4, .5},
		[2] = {.5, .4},
		[3] = {.6, .3},
	}
	local switch = 1
	function thing(beat, col)
		local s = switch
		switch = -switch
		funcQ {beat, 2, function(quad)
			if beat < 222 then
				quad:croptop(0.7)
				quad:cropbottom(0.15)
			end
			quad:cropleft(cropconvert(coldata[col][1]))
			quad:cropright(cropconvert(coldata[col][2]))
		end, function(quad, p)
			quad:y(scy + p * p * sh)
			quad:rotationz(p * 90 * s)
		end}
	end
	local THETA = 0.3217505544
	local R = 158.113883007
	local PI = 3.14159265358979323
	local NINETY = PI * 0.5
	local OFFSET = -2 * THETA * 100 / NINETY
	local sin,cos = math.sin, math.cos

	local fps = 60
	local speed = 7
	func {196, function()
		walloftext:hidden(0)
		walloftext:croptop(1 - speed / walloftext:GetHeight())
		walloftext:texcoordvelocity(0, speed / walloftext:GetHeight() * fps)
		walloftext:vertalign('bottom')
		walloftext:y(sh)
		masksprite:zoom(1)
		masksprite:SetTextureFiltering(true)
		masksprite:y(scy - speed)
		masksprite:GetShader():uniform1f('rate', 1)
		for pn = 1, 2 do
			PJ[pn]:y(sh + 20)
		end
	end}
	{196, function()
		walloftext:glow(.522, .376, .294, 1)
		walloftext:linear(1)
		walloftext:glow(0.522, .376, .294, 0)
	end, persist = false}
	set {196, .65, 'mask'}
	ease {221, 1, linear, .70, 'mask'}
	ease {234, 1, linear, .75, 'mask'}
	ease {266, 1, linear, .80, 'mask'}
	ease {276, 1, linear, .85, 'mask'}
	definemod {
		'rot', 'rotzoom',
		function(rot, rotzoom)
			return
				R * cos(THETA + NINETY * (2 + rot * 0.01)) + (1.5 - 0) * 100,
				R * cos(THETA + NINETY * (1 + rot * 0.01)) + (1.5 - 1) * 100,
				R * cos(THETA + NINETY * (3 + rot * 0.01)) + (1.5 - 2) * 100,
				R * cos(THETA + NINETY * (0 + rot * 0.01)) + (1.5 - 3) * 100,
				R * 0.01 * rotzoom * sin(THETA + NINETY * (2 + rot * 0.01)),
				R * 0.01 * rotzoom * sin(THETA + NINETY * (1 + rot * 0.01)),
				R * 0.01 * rotzoom * sin(THETA + NINETY * (3 + rot * 0.01)),
				R * 0.01 * rotzoom * sin(THETA + NINETY * (0 + rot * 0.01))
		end,
		'movex0', 'movex1', 'movex2', 'movex3', 'movez0', 'movez1', 'movez2', 'movez3'
	}
	add {221, 3, linear, 200, 'rot'}
	add {220, 5, bell, 100, 'rotzoom'}
	ease {248.5, 2, outCubic, 99, 'reverse'}
	func {248.5, 2, outCubic, -7, 7, function(y) masksprite:y(scy+y) end}
	func {248.5, 2, outCubic, sh+20, 40, function(y)
		PJ[1]:y(y)
		PJ[2]:y(y)
	end}
	func {248.5, 2, outCubic}
	func {248, 2, inCubic, sh, speed, function(y)
		walloftext:y(y)
	end}
	func {248, 2, bounce, speed, sh, function(h)
		walloftext:croptop(1 - h / walloftext:GetHeight())
	end}
	func {248, 2, outCubic, speed / walloftext:GetHeight() * fps, -speed / walloftext:GetHeight() * fps, function(s)
		walloftext:texcoordvelocity(0, s)
	end}
	func {222, function()
		P[1]'Judgment''':stoptweening()
		P[2]'Judgment''':stoptweening()
	end, persist=false}
	func {250, function()
		P[1]'Judgment''':stoptweening()
		P[2]'Judgment''':stoptweening()
	end, persist=false}
	local toggle = 1
	for i, v in ipairs(P1:GetNoteData(196, 279)) do
		add {v[1], 1, outBack, toggle == 1 and 100 + OFFSET or -OFFSET, 'rot'}
		add {v[1], .7, pop, 100, 'rotzoom', 100, 'arrowpath', -5000, 'tinyz'}
		add {v[1], 4, pop, toggle * 30, 'rotationz'}
		add {v[1], 3, pop, toggle * 20, 'rotationx'}
		toggle = -toggle
	end
	reset {279.5}
	func {279.5, function() walloftext:hidden(1) end}
end)"
	Type = "ActorFrame"
><children>
</children></Mods>
